# signal

- A *signal* is a notification to a process that an event has occurred. They interrupt the normal flow of execution of a program
- 信号的是从 1 开始的
  - 1--31 是标准信号（*standard signals*）
  - 其他则是实时信号（*the realtime signals*）
  - signal 0 在编程 API 是允许的，可以利用 signal 0 来检查一个进程是否存活。同时接收进程并不会接收到任何的信号
    - 但是这种方法并不算很准确，因为接收者不需要响应 signal，接收者不一定能够提供服务的
- A signal is said to be generated by some event. Once generated, a signal is later delivered to a process, which then takes some action in response to the signal. Between the time it is generated and the time it is delivered, a signal is said to be pending.（信号诞生，到进程收到这个信号，这一段时间的信号，就可以认为是处于 pending 状体的）
- 信号是可以自己传递给自己的，就如比：`exit()`, `abort() ---> SIGABRT`
- signal handler 里面不应该向 `stdout` 打印。real-world applications should generally never call stdio functions from within a signal handler
- signal 不是想发就发的，发送 signal 也是需要权限的



**正确区分 signal 的 action 与 disposition：**

首先是 default action 可以分为：

- term
- core
- ignore
- stop
- cont

个人感觉还有其他 action：

- caught



block 跟 unblock 其实是当前的一种状态，当进程现在不能够接受任何信号中断程序时，就会把相应的 signal block mask 设置为 block，等到可以处理时，就会设置为 unblock

- block
- unblock

举个例子：当一个 signal delivery 给一个函数 handler 之后，这时候，这个进程的相应 signal block mask 就会被置位，当 handler 结束之后，就会是 unblock

```c
/**
 * How to run
 * 1. gcc signal_block.c -o signal_block && ./signal_block
 * 2. cat /proc/`pidof signal_block`/status | grep SigQ -A 5
 * 3. kill -2 `pidof signal_block`
*/

#include <signal.h>
#include <stdio.h>

void signal_handler(int sig)
{
	printf("signal[%d] handler called\n", sig);
	sleep(10); // SigBlk will be set unit signal_handler() finish and exit
	printf("exit signal handler\n", sig);
}

void main()
{
	if (signal(SIGINT, signal_handler) == SIG_ERR)
	{
		printf("fail to call signal()\n");
	}

	printf("signal blocking demo set finish\n");
	while(1)
	{
		sleep(1000);
	}
}
```

触发流程：

```bash
[root@LC signal]# gcc signal_block.c -o signal_block && ./signal_block
signal blocking demo set finish
^Csignal[2] handler called
exit signal handler # 10s 后，signal handler 完成 signal 的处理
```

进程当前 signal 情况：

```bash
[root@LC signal]# cat /proc/`pidof signal_block`/status | grep SigQ -A 5
SigQ:	0/3635
SigPnd:	0000000000000000
ShdPnd:	0000000000000000
SigBlk:	0000000000000002 # 收到 signal，signal_handler() 开始处理 signal 事件，被设置为 block
SigIgn:	0000000000000000
SigCgt:	0000000000000002
[root@LC signal]# 
# 等 signal 处理完毕之后再 cat 一次
[root@LC signal]# cat /proc/`pidof signal_block`/status | grep SigQ -A 5
SigQ:	0/3635
SigPnd:	0000000000000000
ShdPnd:	0000000000000000
SigBlk:	0000000000000000 # 自动设置为 ubblock 了
SigIgn:	0000000000000000
SigCgt:	0000000000000002
[root@LC viper]# 
```

- disposition 的设置，将会改变 default action，从 default action 变成了 caught 了嘛
- 所谓的 action 是这个进程对不同信号会做什么，具体的做法要告诉操作系统，这样操作系统才能帮进程表达出相应的 action 行为
- disposition 通常是 caught action，Linux 操作系统将会帮你把 signal 给到相应的 handler 进行响应处理
- 代码中设置的 `SigIgn` 理解为 disposition 其实更好







- signal mask 通常是是指：**The Signal Mask (Blocking Signal Delivery)**
  - For each process, the kernel maintains a *signal mask*—a set of signals whose **delivery** to the process is **currently** **blocked**.
  - 是特指 block 的 delivery 的
  - 值得注意的是，你在 `/proc/<pid>/status` 中会看到几个 `SigPnd`, `ShdPnd`, `SigBlk`, `SigIgn`, `SigCgt`, 但他们并不是 **The Signal Mask (Blocking Signal Delivery)**，而是采用跟 **The Signal Mask (Blocking Signal Delivery)** 相同的 bit-fields 表达方式，来表示：现在哪些 signal 是正在被这个进程 block、ignore、caught、pending 的
  - 注意，只有这个特指 blocking signal delivery 的 signal mask 才是 per-thread 独立的！

- `SigBlk` 的设置通常会有两个作用：
  - 这个进程此时不能、不方便处理信号，暂时 block 住，不处理这个信号；方便的时候，才 unblock，进行信号处理
  - 这个线程永远不想处理某一个信号，那么这个线程 block 住这个信号就好了，操作系统会尝试发给其他没有 block 这个信号的线程























## Q&A

### 一个 signal 的流程是怎样的？

- 硬件、软件发起一个 signal，并通过 thread-id 或者是 process-id 发给执行的线程或者是进程组
- 操作系统接收到 signal 的发起，并通过 thread-id、process-id 将 signal 发送给相应的线程、进程
- 首先操作系统先检查接受 signal 的线程，对这个 signal 有没什么特殊的设置：
  - 有没有 ignore（`SigIgn`），有的话，不传递这个 signal 给整个进程
  - 有没有设置 disposition？有的话看看整个进程组中哪个线程可以进行处理（同时，`SigCgt` 会置位相应的 bit）
  - 有没有设置 block、或者是因为正在处理同一个 signal 导致 block；直到 unblock 操作系统才会将这个 signal delivery 给进程
  - 这个进程有没有相同的 signal 正在 pending 排队，有的话，drop 这个还没 delivery 给进程的 signale（pending 的时候，`SigPnd`、`ShdPnd` 会置位相应的 bit）
- 操作系统将 signal delivery 给进程，并且设置相应的 `SigBlk` 以阻止相同 signal 再次传递给进程
- 进程开始处理 signal，调用 signal handler
- 进程完成 signal 的处理，退出 signal hander
- 操作系统将相应的  `SigBlk` bit 清空，表明这个进程可以接受下一个相同的 signal



### 什么时候操作系统会给进程发送信号？

> TLPI section 20.1

- A hardware exception occurred, meaning that the hardware detected a fault condition that was notified to the kernel, which in turn sent a corresponding signal to the process concerned. Examples of hardware exceptions include executing a malformed machine-language instruction, dividing by 0, or referencing a part of memory that is inaccessible.
- （通过键盘唤起的）The user typed one of the terminal special characters that generate signals. These characters include the interrupt character (usually Control-C) and the suspend character (usually Control-Z).
- A software event occurred. For example, input became available on a file descriptor, the terminal window was resized, a timer went off, the process's CPU time limit was exceeded, or a child of this process terminated.







### 可靠信号与不可靠信号

> TLPI section 22.7











### signal block, ignore, caught 有什么区别？

- 这些其实都是一种 signal mask。
- the signal mask is actually a per-thread attribute, and that each thread in a multithreaded process can independently examine and modify its signal mask
- 在代码中设置的 `SIG_IGN`（如：`signal(SIGINT, SIG_IGN)`） 其实是设置了一个 disposition，而不是 action
- 而所谓的 block，只是进程暂时不接受这个 signal，当进程 unblock 之后，就会给进程

> TLPI section 20.10
>
> TLPI section 33.2.1

- block 是暂时不传递给这个进程，暂时 pending 住。但是在 unblock 之后，就可以传递给这个进程
  - 被 block 住的是 signal 的 delivery
  - If a signal that is blocked is sent to a process, delivery of that signal **is delayed until** it is unblocked by being removed from the process signal mask.
- ignore 是 linux kernel 在传递给进程之前，发现进程想是 ignore 这个信号的，那么 kernel 就直接 drop 掉这个信号，不传递给进程
  - The signal is ignored; that is, it is discarded by the kernel and has no effect on the process. (The process never even knows that it occurred.)
- caught, 进程接收到了，并且调用了 signal handler
  - When a signal handler is invoked in response to the delivery of a signal, we say that the signal has been handled or, synonymously, *caught*.
  - signal caught by a handler















### 多线程与信号

> TLPI section 33.2

- 多线程 + 信号构建程序模型的话，将会令代码变得复杂、较难预测，如非必要，建议避免使用太多信号



**process-wide VS thread-wide**

> thread-wide 是指，同一个 process 里面的不同 thread

porcess-wide:

- Signal action（default action，stop、terminate）
- Signal dispositions（也就是 signal handler，其实这个 signal 可以理解为变成了 caught）



- （signal hander 是全部线程共享的，全部线程使用同一个 signal handler）Signal dispositions are process-wide; all threads in a process share the same disposition for each signal.
  - Similarly, if one thread sets the disposition of a signal to ignore, then that signal is ignored by all threads.
- Signal actions are process-wide. 是指 action 的影响范围，而不是所有 thread 都采用相同的 action
- When a new thread is created, it inherits a copy of the signal mask of the thread that created it. 
- The signal mask is per-thread. signal mask 特指：**The Signal Mask (Blocking Signal Delivery)**；也就意味着，不同的 thread 可以独立 block 不同的 signal，这样这个 thread 在 block 的期间，就永远不会收到这个 signal 了
  -  Threads can independently block or unblock different signals using pthread_sigmask()
  - By manipulating the per-thread signal masks, an application can control which thread(s) may handle a signal that is directed to the whole process.
  - When a new thread is created, it inherits a copy of the signal mask of the thread that created it. 
- signal 是可以打断 mutex 的，为了修复这个问题，mutex 将会进行重试









**什么情况下，signal 会只给一个 thread？**

- SIGBUS, SIGFPE, SIGILL, and SIGSEGV 这种硬件信号发生的时候，会准确传给触发这个 signal 的 thread
- it is a SIGPIPE signal generated when the thread tried to write to a broken pipe
- 通过 thread id 发送的信号
- 其他情况下，signal 一般是看 process 里面哪个 thread 有空，就给哪个（前提是你这个 thread 没有 block 这个 signal）





















































# /proc 怎么观察 signal ？

##  `cat /proc/[pid]/status`

> man proc
>
> man signal

```bash
[root@LC signal]# cat /proc/15015/status 
Name:	thread_inherit_
........
State:	S (sleeping)
Tgid:	15014
Pid:	15015
........
Threads:	2
SigQ:	0/3635  # 待处理信号数 / 这个 thread 一共可以等待几个信号
SigPnd:	0000000000000000 # per-thread pending signals
ShdPnd:	0000000000000000 # process-wide pending signals, Signals pending for process
SigBlk:	0000000000000000 # 哪些信号被 block，从右向左，信号编号从 1 到 max
SigIgn:	0000000000000000 # 哪些信号被 ignore
SigCgt:	0000000180000000 # 哪些信号被 caught
```



**The difference between the SigPnd and ShdPnd fields**

> TLPI section 33.2

// ==TODO==







